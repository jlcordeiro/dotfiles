#!/bin/bash
#
# /etc/rc.sysinit
#

. /etc/rc.conf
. /etc/rc.d/functions

echo " "
printhl "Arch Linux\n"
printhl "${C_H2}http://www.archlinux.org"
printhl "Copyright 2002-2007 Judd Vinet"
printhl "Copyright 2007-2009 Aaron Griffin"
printhl "Distributed under the GNU General Public License (GPL)"
printsep

# mount /proc, /sys and our RAM /dev
/bin/mount -n -t ramfs none /dev
/bin/mount -n -t proc none /proc
/bin/mount -n -t sysfs none /sys

# Create our default nodes that minilogd may need
/bin/mknod /dev/null c 1 3
/bin/mknod /dev/zero c 1 5
/bin/mknod /dev/console c 5 1

# More initial /dev setup that udev doesn't do
/bin/ln -snf /proc/self/fd /dev/fd
/bin/ln -snf /proc/self/fd/0 /dev/stdin
/bin/ln -snf /proc/self/fd/1 /dev/stdout
/bin/ln -snf /proc/self/fd/2 /dev/stderr
/bin/ln -snf /proc/kcore /dev/core
/bin/mkdir /dev/pts
/bin/mkdir /dev/shm

# start up our mini logger until syslog takes over
/sbin/minilogd

# anything more serious than KERN_WARNING goes to the console
# 'verbose' cmdline parameter enables more messages
if /bin/grep -q " verbose" /proc/cmdline; then
    /bin/dmesg -n 8
else
    /bin/dmesg -n 3
fi

# enable rtc access
/sbin/modprobe rtc-cmos >/dev/null 2>&1
RTC_MAJOR=$(/bin/grep -w rtc /proc/devices 2>/dev/null); RTC_MAJOR="${RTC_MAJOR%% *}"
if [ -n "$RTC_MAJOR" ]; then
    /bin/mkdir /dev/misc/
    /bin/mknod /dev/misc/rtc0 c $RTC_MAJOR 0
    /bin/ln -s /dev/misc/rtc0 /dev/rtc
fi

# Set clock early to fix some bugs with filesystem checks
# Clock is set again later to match rc.conf
if [ -f /etc/localtime ]; then
    /sbin/hwclock $HWCLOCK_PARAMS --hctosys --localtime --directisa --noadjfile
fi

echo > /proc/sys/kernel/hotplug

if [ -x /sbin/udevadm -a -d /sys/block ]; then
    # We have udev and /sys appears to be mounted, use UDev
    stat_busy "Starting UDev Daemon"
    /sbin/udevd --daemon
    /sbin/udevadm trigger
    udevstart="$(/bin/date +%s%0N)"
    stat_done
else
    # Static /dev, our last resort
    status "Using static /dev filesystem" true
fi

# Load modules from the MODULES array defined in rc.conf
if ! [ "$load_modules" = "off" ]; then
    if [ -f /proc/modules ]; then
        stat_busy "Loading Modules"
        for mod in "${MODULES[@]}"; do
            if [ "$mod" = "${mod#!}" ]; then
                /sbin/modprobe $mod &
            fi
        done
        stat_done
    fi
    if [ -d /proc/acpi ]; then
        stat_busy "Loading standard ACPI modules"
        ACPI_MODULES="ac battery button fan processor thermal"
        k="$(echo $BLACKLIST ${MOD_BLACKLIST[@]} | /bin/sed 's|-|_|g')"
        j="$(echo ${MODULES[@]} | /bin/sed 's|-|_|g')"
        #add disabled MODULES (!) to blacklist - much requested feature
        for m in ${j}; do
                [ "$m" != "${m#!}" ] && k="${k} ${m#!}"
        done
        # add disablemodules= from commandline to blacklist
        k="${k} $(echo ${disablemodules} | /bin/sed 's|-|_|g' | /bin/sed 's|,| |g')"
        for n in ${ACPI_MODULES}; do
            if ! echo ${k} | /bin/grep "\<$n\>" 2>&1 >/dev/null; then
                /sbin/modprobe $n > /dev/null 2>&1 &
            fi
        done
        stat_done
    fi
fi

# run udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
    stat_busy "Loading UDev uevents"
    /sbin/udevadm settle
    stat_done
    udevend="$(/bin/date +%s%0N)"
    printhl "   UDev uevent processing time: $((($udevend-$udevstart)/1000000))ms"
fi

# bring up the loopback interface
if [ -d /sys/class/net/lo ]; then
    stat_busy "Bringing up loopback interface"
    /sbin/ifconfig lo 127.0.0.1 up &
    if [ $? -ne 0 ]; then
        stat_fail
    else
        stat_done
    fi
fi

status "Mounting Root Read-only" /bin/mount -n -o remount,ro /

FORCEFSCK=
[ -f /forcefsck ] && FORCEFSCK="-- -f"
NETFS="nonfs,nonfs4,nosmbfs,nocifs,nocodafs,noncpfs,nosysfs,noshfs,nofuse,nofuseblk"

if [ -x /sbin/fsck ]; then
    stat_busy "Checking Filesystems"
    if /bin/grep -qw quiet /proc/cmdline; then
        /sbin/fsck -A -T -C -a -t $NETFS $FORCEFSCK >/dev/null 2>&1
    else
        /sbin/fsck -A -T -C -a -t $NETFS $FORCEFSCK 2>/dev/null
    fi
    fsckret=$?
    if [ ${fsckret} -gt 1 ]; then
        stat_fail
        if [ $((${fsckret}&2)) -eq 2 ]; then
            echo
            echo "********************** REBOOT REQUIRED *********************"
            echo "*                                                          *"
            echo "* The system will be rebooted automatically in 15 seconds. *"
            echo "*                                                          *"
            echo "************************************************************"
            echo
            /bin/sleep 15
        else
            echo
            echo "*****************  FILESYSTEM CHECK FAILED  ****************"
            echo "*                                                          *"
            echo "*  Please repair manually and reboot. Note that the root   *"
            echo "*  file system is currently mounted read-only. To remount  *"
            echo "*  it read-write type: mount -n -o remount,rw /            *"
            echo "*  When you exit the maintenance shell the system will     *"
            echo "*  reboot automatically.                                   *"
            echo "*                                                          *"
            echo "************************************************************"
            echo
            /sbin/sulogin -p
        fi
        echo "Automatic reboot in progress..."
        /bin/umount -a
        /bin/mount -n -o remount,ro /
        /sbin/reboot -f
        exit 0
    fi
    stat_done
fi

stat_busy "Mounting Local Filesystems"
/bin/mount -n -o remount,rw /
/bin/rm -f /etc/mtab*
# make sure / gets written to /etc/mtab
/bin/mount -o remount,rw /
# Write /proc, /sys and /dev to /etc/mtab
if [ -e /proc/mounts ]; then
    /bin/grep -e "/proc " -e "/sys " -e "/dev " /proc/mounts >> /etc/mtab
fi
# now mount all the local filesystems
/bin/mount -a -t $NETFS
stat_done

status "Activating Swap" /sbin/swapon -a &

stat_busy "Configuring System Clock"
if [ ! -f /var/lib/hwclock/adjtime ]; then
    echo "0.0 0 0.0" > /var/lib/hwclock/adjtime &
fi

/bin/rm -f /etc/localtime
/bin/cp "/usr/share/zoneinfo/Europe/Lisbon" /etc/localtime &
/sbin/hwclock --hctosys --localtime --directisa --noadjfile &
stat_done

if [ -f /var/run/random-seed ]; then
    stat_busy "Initializing Random Seed"
    /bin/cat /var/run/random-seed >/dev/urandom
    stat_done
fi

stat_busy "Removing Leftover Files"
/bin/rm -f /etc/nologin &>/dev/null
/bin/rm -f /etc/shutdownpid &>/dev/null
/bin/rm -f /var/lock/* &>/dev/null
/bin/rm -rf /tmp/* /tmp/.* &>/dev/null
/bin/rm -f /forcefsck &>/dev/null
(cd /var/run && /usr/bin/find . ! -type d -exec /bin/rm -f -- {} \; )
: > /var/run/utmp
/bin/chmod 0664 /var/run/utmp
# Keep {x,k,g}dm happy with xorg
/bin/mkdir /tmp/.ICE-unix && /bin/chmod 1777 /tmp/.ICE-unix
/bin/mkdir /tmp/.X11-unix && /bin/chmod 1777 /tmp/.X11-unix
stat_done

#status "Updating Shared Library Links" /sbin/ldconfig

if [ "$HOSTNAME" != "" ]; then
    status "Setting Hostname: localhost" /bin/hostname localhost &
fi

#status "Updating Module Dependencies" /sbin/depmod -A

# Flush old locale settings
: >/etc/profile.d/locale.sh
/bin/chmod 755 /etc/profile.d/locale.sh
# Set user defined locale
[ -z "$LOCALE" ] && LOCALE="en_US"
stat_busy "Setting Locale: $LOCALE"
echo "export LANG=$LOCALE" >>/etc/profile.d/locale.sh
stat_done

stat_busy "Setting Consoles to UTF-8 mode"
# UTF-8 consoles are default since 2.6.24 kernel
# this code is needed when user has set vt.default_utf8=0 but LOCALE is *.UTF-8.
for i in $(/usr/bin/seq 0 63); do
    /usr/bin/kbd_mode -u < /dev/vc/${i}
    printf "\e%%G" > /dev/vc/${i}
done
# the $CONSOLE check helps us avoid this when running scripts from cron
echo 'if [ "$CONSOLE" = "" -a "$TERM" = "linux" -a -t 1 ]; then printf "\e%%G"; fi' >>/etc/profile.d/locale.sh
stat_done
[ -n "$KEYMAP" ] && status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q -u $KEYMAP

# Adding persistent network/cdrom generated rules
if [ -f "/dev/.udev/tmp-rules--70-persistent-cd.rules" ]; then
    stat_busy "Adding persistent cdrom udev rules"
    /bin/cat /dev/.udev/tmp-rules--70-persistent-cd.rules >> /etc/udev/rules.d/70-persistent-cd.rules
    stat_done
fi
if [ -f "/dev/.udev/tmp-rules--70-persistent-net.rules" ]; then
    stat_busy "Adding persistent network udev rules"
    /bin/cat /dev/.udev/tmp-rules--70-persistent-net.rules >> /etc/udev/rules.d/70-persistent-net.rules
    stat_done
fi

# Save our dmesg output from this boot
if [ -f /var/log/dmesg.log ]; then
    /bin/rm /var/log/dmesg.log
fi
/bin/dmesg > /var/log/dmesg.log &

# End of file
# vim: set ts=2 noet:
