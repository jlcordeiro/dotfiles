

#define USE_XENOMAI


#ifdef USE_XENOMAI
// #include <native/task.h>
#include <native/timer.h>
#include <rtdk.h>
#define MR_GET_TIME_NS() (rt_timer_read())
#endif

#ifdef USE_RTAI
#ifdef USE_XENOMAI
#error USE_XENOMAI AND USE_RTAI simultaneously defined
#endif
#include <rtai_lxrt.h>
#define MR_GET_TIME_NS() (rt_get_cpu_time_ns())
#endif	



#include <iostream>
#include "teachplay.hpp"




using namespace std;


void print_gsl_matrix(gsl_matrix *m, char *s){
    printf("\n\n%s=[\n",s);
    for(unsigned int i=0; i<m->size1 ;i++){
        printf("    ");
        for(unsigned int j=0; j<m->size2; j++)
            printf("%5.10lf   ", GSL_MATRIX_GET(m,i,j));
        printf(" \n");
    }
    printf("]\n\n");
}

void print_gsl_vector(gsl_vector *m, char *s){
    printf("\n\n%s=[\n",s);
    for(unsigned int i=0; i<m->size ;i++){

        printf("%5.10lf   ", gsl_vector_get(m,i));

    }
    printf("]\n\n");
}


    TeachPlay::TeachPlay(Real q_matrix[DOF], Real tau_matrix[DOF], Real g_vector[3], const Real sample_time)
:active(false),
    currentAction(none),
    controlers_correctly_loaded(true),
    h(sample_time),
    q(q_matrix),
    refTab(0),
    refTabSize(0),
    robot(q_matrix,qd_filtered,g_vector),
    teachFname(DEFAULT_TEACH_FILE),
    PlayResultsFname(DEFAULT_PLAY_RESULTS_FILE)
{
    pthread_mutex_init(&internal_variables_mutex,NULL);

    Real ref_time_const=1.0/(2.0*M_PI*REF_CUT_FREQ);
    alpha_ref=h/(h+ref_time_const);

    tau_view=gsl_vector_view_array ((double*)tau_matrix,DOF);
    x_state_ini=gsl_vector_alloc (4);
    tau_star=gsl_vector_alloc (DOF);
    bool success;
    bool failed_initialize=false;
    for (int i=0;i<DOF;i++)
    {
        joint_controler_fast[i]=new AOBcold (fast_controlerConfFileNames[i],aobName[i],success,h);
        if(!success)
            failed_initialize=true;
        // 		joint_controler_slow[i]=new AOBcold (slow_controlerConfFileNames[i],aobName[i],success,h);
        // 		if(!success)
        // 			failed_initialize=true;
    }
    if(failed_initialize)
    {
        cerr<<"\t\t\t\t***************************************************\n";
        cerr<<"\t\t\t\tcontrolers config files NOT correctly READED!!!\n"<< "\t\t\t\tplease reload them!! (ONLY Teach mode is avaliable)\n";
        cerr<<"\t\t\t\t***************************************************\n";
        controlers_correctly_loaded=false;
    }

    alpha_qd = h/((1.0/(2.0*M_PI*QD_CUT_FREQ)) + h);
    for(int i=0;i<DOF;i++){
        qd_filtered[i]=0.0;
        qd[i]=q[i];
    }

#ifdef USE_XENOMAI
/* Perform auto-init of rt_print buffers if the task doesn't do so */
	rt_print_auto_init(1);
#endif

    ti= MR_GET_TIME_NS();
    tf= MR_GET_TIME_NS();
}



TeachPlay::~TeachPlay()
{
    pthread_mutex_destroy(&internal_variables_mutex);
    // 	free controlers
    for (int i=0;i<DOF;i++)
    {
        delete joint_controler_fast[i];
        // 		delete joint_controler_slow[i];
    }

    if(refTab!=0)
    {
        for(int i=0;i<refTabSize;i++)
            delete [] refTab[i];
        delete [] refTab;
    }
    // 	free vectors and matrixes
    gsl_vector_free(x_state_ini);
    gsl_vector_free(tau_star);


    if(playResultsFile.is_open()) playResultsFile.close();
    if(teachFile.is_open()) teachFile.close();

}




    void
TeachPlay::control_it()
{
    tf=MR_GET_TIME_NS();
    double elapsed_time_seconds = static_cast<double>(ti- tf) * 1.0e-9;
    // 	printf("elapsed_time_seconds: %lf\n",elapsed_time_seconds);
    //    print_gsl_vector(VECTOR_VIEW(q_view),"q");



    for(int i=0;i<DOF;i++){
        //    Calculates de joint's velocity (qd)
        //    q_(k-1) value was previously stored in the qd vector
        // 		qd[i]=(q[i]-qd[i])/h;
        qd[i]=(q[i]-qd[i])/elapsed_time_seconds;

        qd_filtered[i]= qd_filtered[i] + alpha_qd * (qd[i]-qd_filtered[i]);
        // 		printf("qd[%d]:%f ",i,qd_filtered[i]);
    }

    // 	printf("\n");
    gsl_vector_set_zero (VECTOR_VIEW(tau_view));                //tau=0

    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
    {
        robot.computeCoriolisVector(); ///WARNING coriolis term introduces torque steps
        gsl_vector_add (VECTOR_VIEW(tau_view),robot.v);//tau+=v(q,qd)

        // 		print_gsl_vector(robot.v,"C");

        robot.computeGravityVector();
        gsl_vector_add (VECTOR_VIEW(tau_view),robot.g);//tau+=g(q)



        if (currentAction==teach)
            save_data();

        if (currentAction==play)
        {
            // 	Forward Kinematic Computation
            robot.forwardKin();
            // 	Jacobians Computation
            robot.computeJacobians();
            // 	Mass Matrix computation
            robot.computeMassMatrix();

            reproduce_data();
        }




    }
    pthread_mutex_unlock(&internal_variables_mutex);


    //    stores the q value into qd vector
    memcpy(qd,q,DOF*sizeof(Real));

    ti= MR_GET_TIME_NS();
}

    void
TeachPlay::save_data() //protected by mutex
{
    if (currentcyclenumber>=ncycles2recordSamples)
    {
        currentcyclenumber=0;
        for (int i=0;i<DOF;i++)
            teachFile<<q[i]<<" ";
        teachFile<<"\n";
    }

    currentcyclenumber++;

    // 	if (ref2control_idx!=0)
    // 	{
    // // 			save the joint positions and the torques
    // 		for (int i=0;i<DOF;i++)
    // 			playResultsFile<<q[i]<<" ";
    // 		for (int i=0;i<DOF;i++)
    // 			playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";
    // 		playResultsFile<<"\n";
    // 	}
}


// void
// TeachPlay::reproduce_data()
// {
//
// 	static Real error_pos[DOF];
// 	static bool achieved;
// 	for(int i=0;i<DOF;i++)
// 		error_pos[i]=fabs(refTab[ref2control_idx][i]-q[i]);
// 	if ((currentcyclenumber>=ncycles2reproduceSamples) && (ref2control_idx<(refTabSize-1)))
// 	{
// 		if(ref2control_idx==0)
// 		{
//
// 			achieved=true;
// 			for(int i=0;i<DOF;i++)
// 				if(error_pos[i]>(0.5/180.0*PI))
// 					achieved=false;
// 			if(achieved)
// 			{
// 				rt_make_soft_real_time();
// 				printf("\nACHIEVED");
// 				rt_make_hard_real_time();
//
// 				//change the controler in use ande initialize it
// 				controler_in_use=joint_controler_fast;
// 				initialize_controlers(controler_in_use);
//
// 				//increases the controlers reference
// 				ref2control_idx++;
//
// 				currentcyclenumber=-1;
// 			}
//
// 		}
// 		else
// 		{
// 			// 	save the joint positions and the torques
// 			for (int i=0;i<DOF;i++)
// 				playResultsFile<<q[i]<<" ";
// 			for (int i=0;i<DOF;i++)
// 				playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";
// 			playResultsFile<<"\n";
//
// 			currentcyclenumber=-1;
// 			//change the controlers reference
// 			ref2control_idx++;
// 		}
// 	}
//
// 	currentcyclenumber++;
//

// // 	//run the controlers
// 	gsl_vector_set_zero(tau_star);
// 	for(int i=0;i<DOF;i++)
// 	{
// // 		printf("\n\n\n\n\n\ncontroler:%d\n",i);
// // 		controler_in_use[i]->calc_output(1,2);
// 		GSL_VECTOR_SET(tau_star,i,controler_in_use[i]->calc_output(refTab[ref2control_idx][i],q[i]));
// 	}
// // 		currentAction=none;
// // 		printf("ref:%lf q:%lf",refTab[ref2control_idx][1],q[1]);
// // 	rt_make_soft_real_time();
// // 	print_gsl_vector(tau_star,"tau_star");
// // 	rt_make_hard_real_time();
//

// }

    void
TeachPlay::reproduce_data() //protected by mutex
{


    static Real error_pos[DOF];
    static bool achieved;

    if (ref2control_idx==0)
    {
        achieved=true;
        for(int i=0;i<DOF;i++)
        {
            if((error_pos[i]=fabs(refTab[ref2control_idx][i]-q[i]))>MIN_ERROR)
                achieved=false;

            if(qi[i]>refTab[ref2control_idx][i])
            {
                if(controler_ref[i]>refTab[ref2control_idx][i])
                    controler_ref[i]=-GOHOME_VELOCITY*h*currentcyclenumber+qi[i];
                else
                    controler_ref[i]=refTab[ref2control_idx][i];
            }
            else
            {
                if(controler_ref[i]<refTab[ref2control_idx][i])
                    controler_ref[i]=GOHOME_VELOCITY*h*currentcyclenumber+qi[i];
                else
                    controler_ref[i]=refTab[ref2control_idx][i];
            }
        }

        if(achieved)
        {
#ifdef USE_RTAI
            rt_make_soft_real_time();
            printf("\nACHIEVED\n");
            rt_make_hard_real_time();
#endif
#ifdef USE_XENOMAI
           rt_printf("\nACHIEVED\n");
#endif
            currentcyclenumber=0;
            //change the controlers reference
            ref2control_idx++;
            for(int i=0;i<DOF;i++)
                controler_ref[i]=refTab[ref2control_idx][i];
        }
    }
    else
    {
        if ((currentcyclenumber>=ncycles2reproduceSamples) && (ref2control_idx<(refTabSize-1)))
        {
            currentcyclenumber=0;
            // 			change the controlers reference
            ref2control_idx++;
            for(int i=0;i<DOF;i++)
                controler_ref[i]=refTab[ref2control_idx][i];
        }
    }


    currentcyclenumber++;




    for(int i=0;i<DOF;i++)
    {
        ref_filtered[i]=alpha_ref*controler_ref[i]+(1-alpha_ref)*ref_filtered[i];
        GSL_VECTOR_SET(tau_star,i,controler_in_use[i]->calc_output(ref_filtered[i],q[i]));
    }

    gsl_blas_dgemv (CblasNoTrans,1,robot.M,tau_star,1,VECTOR_VIEW(tau_view));

    if (ref2control_idx!=0)
    {
        // 			save the joint positions and the torques
        for (int i=0;i<DOF;i++)
            playResultsFile<<q[i]<<" ";
        for (int i=0;i<DOF;i++)
            playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";

        // 		for (int i=0;i<DOF;i++)
        // 			playResultsFile<<GSL_VECTOR_GET(robot.v,i)<<" ";

        // 		for (int i=0;i<DOF;i++)
        // 			playResultsFile<<qd[i]<<" ";

        // 		for (int i=0;i<DOF;i++)
        // 			playResultsFile<<qd_filtered[i]<<" ";

        // 		for (int i=0;i<DOF;i++)
        // 			playResultsFile<<GSL_VECTOR_GET(tau_star,i)<<" ";

        playResultsFile<<"\n";
    }

}





    bool
TeachPlay::loadControlFiles()
{
    if(currentAction==play)
        return false;

    bool success=true;
    pthread_mutex_lock(&internal_variables_mutex);
    for (int i=0;i<DOF;i++)
    {
        success=joint_controler_fast[i]->reloadConfigFiles();
        if(!success)
            break;
        // 		success=joint_controler_slow[i]->reloadConfigFiles();
        // 		if(!success)
        // 			break;
    }
    pthread_mutex_unlock(&internal_variables_mutex);
    controlers_correctly_loaded=success;
    return success;
}




    void
TeachPlay::toggleAppState()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active && currentAction==none)
        active=false;
    else{
        // 		for(int i=0;i<DOF;i++)
        // 		{
        // 		qd[i]=q[i];
        // 		}
        active=true;
    }
    pthread_mutex_unlock(&internal_variables_mutex);
}

    bool
TeachPlay::isAppActive()
{
    return active;
}

    TeachPlay::action
TeachPlay::getAction()
{
    return currentAction;
}


    TeachPlay::results
TeachPlay::enableTeach()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(prepare4teach()) //TODO review if its correct
                {
                    pthread_mutex_lock(&internal_variables_mutex);
                    currentAction=teach;
                    pthread_mutex_unlock(&internal_variables_mutex);
                    return success;
                }
                else
                    return error;
                break;

            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(disablePlay()== success)
                {
                    if(prepare4teach()) //TODO review if its correct
                    {
                        pthread_mutex_lock(&internal_variables_mutex);
                        currentAction=teach;
                        pthread_mutex_unlock(&internal_variables_mutex);
                        return success;
                    }
                    else
                        return error;
                }
                else
                    return error;
                break;
            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}



    TeachPlay::results
TeachPlay::enablePlay()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(prepare4play()) //TODO review if its correct
                {
                    pthread_mutex_lock(&internal_variables_mutex);
                    currentAction=play;
                    pthread_mutex_unlock(&internal_variables_mutex);
                    return success;
                }
                else
                    return error;
                break;

            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(disableTeach()== success)
                {
                    if(prepare4play()) //TODO review if its correct
                    {
                        pthread_mutex_lock(&internal_variables_mutex);
                        currentAction=play;
                        pthread_mutex_unlock(&internal_variables_mutex);
                        return success;
                    }
                    else
                        return error;
                }
                else
                    return error;
                break;
            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}


    TeachPlay::results
TeachPlay::disableTeach()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;

            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case teach:

                finishteach(); //TODO review if its correct
                currentAction=none;
                pthread_mutex_unlock(&internal_variables_mutex);
                return success;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}


    TeachPlay::results
TeachPlay::disablePlay()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case play:
                finishplay(); //TODO review if its correct
                currentAction=none;
                pthread_mutex_unlock(&internal_variables_mutex);
                return success;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}



    bool
TeachPlay::prepare4teach()
    // this function opens the file to record the joint positions from the WAM
{

    pthread_mutex_lock(&internal_variables_mutex);

    teachFile.open(teachFname.c_str(),ios::out);

    if(!teachFile.is_open()) return false;

    teachFile.setf(std::ios::fixed);
    teachFile.precision(4);

    teachFile<<"  %q1      q2      q3     q4     q5     q6      q7\n";

    pthread_mutex_unlock(&internal_variables_mutex);

    ncycles2recordSamples=(int)(DATACQUISITIONTIME/h+0.5);
    currentcyclenumber=0;
    cout<<"\nncycles2recordSamples:"<<ncycles2recordSamples<<"\n";


    // 	playResultsFile.open(PlayResultsFname.c_str(),ios::out);
    //
    // 	if(!playResultsFile.is_open()) return false;
    //
    // 	playResultsFile.setf(std::ios::fixed);
    // 	playResultsFile.precision(4);
    //
    // 	playResultsFile<<"     %q1     q2    q3     q4    q5      q6     q7     tau1    tau2    tau3     tau4   tau5   tau6   tau7\n";
    return true;
}


    bool
TeachPlay::finishteach() //protected by mutex
    // this function closes the file to record the joint positions from the WAM
{
    if(teachFile.is_open()) teachFile.close();
    if(playResultsFile.is_open()) playResultsFile.close();

    return true;
}




    bool
TeachPlay::prepare4play()
{
    if(!controlers_correctly_loaded)
    {
        cerr<<"\t\t\t\t***************************************************\n";
        cerr<<"\t\t\t\tcontrolers config files NOT correctly READED!!!\n"<< "\t\t\t\tplease reload them!! (ONLY Teach mode is avaliable)\n";
        cerr<<"\t\t\t\t***************************************************\n";
        return false;
    }

    if(!readReferences4table())
        return false;



    pthread_mutex_lock(&internal_variables_mutex);

    ncycles2reproduceSamples=(int)(DATAREPRODUCTIONTIME/h+0.5);
    cout<<"\nncycles2playSamples:"<<ncycles2reproduceSamples<<"\n";

    currentcyclenumber=0;
    ref2control_idx=0;
    controler_in_use=joint_controler_fast;

    initialize_controlers(controler_in_use,q);

    for(int i=0;i<DOF;i++)
    {
        qi[i]=q[i];
        controler_ref[i]=q[i];
        ref_filtered[i]=q[i];
    }

    pthread_mutex_unlock(&internal_variables_mutex);

    // 	cout<<"\n";

    return true;
}



    bool
TeachPlay::finishplay()  //protected by mutex
{
    if(refTab!=0)
    {
        for(int i=0;i<refTabSize;i++)
            delete [] refTab[i];
        delete [] refTab;
        refTab=0;
    }


    if(playResultsFile.is_open()) playResultsFile.close();

    return true;
}

    void
TeachPlay::initialize_controlers(AOBcold **controler,Real ref[DOF])
{
    gsl_vector_set_zero(x_state_ini);
    for (int i=0;i<DOF;i++)
    {
        // 	initialize internal states
        GSL_VECTOR_SET(x_state_ini,0,q[i]);
        // 		print_gsl_vector(x_state_ini,"x_state_ini");
        controler[i]->setX_State(x_state_ini);

        // 	set the first reference and internal variables
        controler[i]->set_REF(ref[i]);
        controler[i]->reset_internal_variables(q[i]);
    }
}


    bool
TeachPlay::readReferences4table()
{
    teachFile.open(teachFname.c_str(),ios::in);

    if(!teachFile.is_open()) return false;

    // 	reads the number of lines in file
    refTabSize=0;
    char aux[150];
    cout<<"\nlocation:"<<teachFile.tellg()<<"\n";
    while( /*teachFile.ignore(3000, '\n' )*/!teachFile.eof() )
    {
        teachFile.getline(aux,150,'\n');
        // 		cout<<"\naux:"<<aux<<"\n";
        refTabSize+=1;
    }
    refTabSize-=2;//decrements the header and the last line because doesn't have information
    cout<<"\n"<<refTabSize<<" readed lines\n";


    teachFile.close();
    std::fstream teachFile_a;
    teachFile_a.open(teachFname.c_str(),ios::in);


    // 	teachFile_a.seekg(0,ios::beg); //Set the position of the get pointer in the begining of file
    // 	cout<<"\nlocation:"<<teachFile.tellg()<<"\n";

    // 	cout<<"\nlocation:"<<teachFile.tellg()<<"\n";

    teachFile_a.seekg(0,ios::beg); //Set the position of the get pointer in the begining of file
    char header1[150];
    teachFile_a.getline(header1,150);//removes the header
    cout<<"\nheader1:"<<header1<<"\n";
    cout<<"\nlocation:"<<teachFile_a.tellg()<<"\n";

    refTab=new Real* [refTabSize];
    for(int i=0;i<refTabSize;i++)
    {
        refTab[i]=new Real [DOF];
        for(int j=0;j<DOF;j++){
            teachFile_a>>refTab[i][j];
            // 			cout<<refTab[i][j]<<" ";
        }
        // 		cout<<"\n";
    }


    // 	for(int j=0;j<DOF;j++){
    // 		teachFile_a>>refTab[0][j];
    // 		cout<<refTab[0][j]<<" ";
    // 	}


    teachFile_a.close();


    playResultsFile.open(PlayResultsFname.c_str(),ios::out);

    if(!playResultsFile.is_open()) return false;

    playResultsFile.setf(std::ios::fixed);
    playResultsFile.precision(4);

    playResultsFile<<"     %q1     q2    q3     q4    q5      q6     q7     tau1    tau2    tau3     tau4   tau5   tau6   tau7\n";

    return true;
}
