#include <iostream>
#include <sys/time.h>
#include "teachplay.hpp"


using namespace std;


void print_gsl_matrix( const gsl_matrix *m, char *s){
    unsigned int i,j;
    cout<<"\n\n"<<s<<"=[\n";
    for(i=0; i<m->size1 ;i++){
        cout<<"    ";
        for(j=0; j<m->size2; j++)
            cout<<m->data[i*m->tda+j]<<"   ";
        cout<<" \n";
    }
    cout<<"]\n\n";
}

void print_gsl_vector( const gsl_vector *m, char *s){
    unsigned int i;
    cout<<"\n\n"<<s<<"=[\n";
    for(i=0; i<m->size ;i++){
        cout<<m->data[i*m->stride]<<"   ";

    }
    cout<<"]\n\n";
}


    TeachPlay::TeachPlay(Real q_matrix[DOF], Real tau_matrix[DOF], Real g_vector[3], const Real sample_time)
:active(false),
    currentAction(none),
    controlers_correctly_loaded(true),
    h(sample_time),
    q(q_matrix),
    refTab(0),
    refTabSize(0),
    robot(q_matrix,qd_filtered,g_vector),
    teachFname(DEFAULT_TEACH_FILE),
    PlayResultsFname(DEFAULT_PLAY_RESULTS_FILE)
{
    pthread_mutex_init(&internal_variables_mutex,NULL);

    Real ref_time_const=1.0/(2.0*M_PI*REF_CUT_FREQ);
    alpha_ref=h/(h+ref_time_const);

    tau_view=gsl_vector_view_array ((double*)tau_matrix,DOF);
    x_state_ini=gsl_vector_alloc (4);
    tau_star=gsl_vector_alloc (DOF);
    bool success;
    bool failed_initialize=false;
    for (int i=0;i<DOF;i++)
    {
        joint_controler_fast[i]=new AOBcold (fast_controlerConfFileNames[i],aobName[i],success,h);
        if(!success)
            failed_initialize=true;
        // 		joint_controler_slow[i]=new AOBcold (slow_controlerConfFileNames[i],aobName[i],success,h);
        // 		if(!success)
        // 			failed_initialize=true;
    }
    if(failed_initialize)
    {
        std::cout<<"***************************************************\n";
        std::cout<<"controlers config files NOT correctly READED!!!\n"<< " please reload them!! (ONLY Teach mode is avaliable)\n";
        std::cout<<"***************************************************\n";
        controlers_correctly_loaded=false;
    }
    // 	else{
    // 		std::cout<<"***************************************************\n";
    // 		std::cout<<"                              LOADED!!!            \n";
    // 		std::cout<<"***************************************************\n";
    // 	}



    alpha_qd = h/((1.0/(2.0*M_PI*QD_CUT_FREQ)) + h);
    for(int i=0;i<DOF;i++){
        qd_filtered[i]=0.0;
        qd[i]=q[i];
    }
}


TeachPlay::~TeachPlay()
{
    pthread_mutex_destroy(&internal_variables_mutex);
    // 	free controlers
    for (int i=0;i<DOF;i++)
    {
        delete joint_controler_fast[i];
        // // 		delete joint_controler_slow[i];
    }
    //
    if(refTab!=0)
    {
        for(int i=0;i<refTabSize;i++)
            delete [] refTab[i];
        delete [] refTab;
    }
    // // 	free vectors and matrixes
    gsl_vector_free(x_state_ini);
    gsl_vector_free(tau_star);


    if(playResultsFile.is_open()) playResultsFile.close();
    if(teachFile.is_open()) teachFile.close();

}




    void
TeachPlay::control_it()
{
    // 	static int olaola=1;
    // 	if(olaola){
    // 	for(int i=0;i<DOF;i++)
    // 		std::cout<<"q["<<i<<"]="<<q[i]<<" ";
    // 	std::cout<<std::endl;
    // 	olaola=0;
    // 	}
    // 	static int olaola=1;
    // 	if(olaola){
    // 		std::cout<<"q_addr:"<<q<<std::endl;
    // 		for(int i=0;i<DOF;i++)
    // 			std::cout<<"q["<<i<<"]="<<q[i]<<" ";
    // 		std::cout<<std::endl;
    //    print_gsl_vector(VECTOR_VIEW(q_view),"q");
    //    	olaola=0;
    // 	}



    gsl_vector_set_zero (VECTOR_VIEW(tau_view));                //tau=0

    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
    {

        for(int i=0;i<DOF;i++){
            //    Calculates de joint's velocity (qd)
            //    q_(k-1) value was previously stored in the qd vector
            qd[i]=(q[i]-qd[i])/h;
//             qd[i]=(q[i]-qd[i])/elapsed_time_seconds;

            qd_filtered[i]= qd_filtered[i] + alpha_qd * (qd[i]-qd_filtered[i]);
            // 		printf("qd[%d]:%f ",i,qd_filtered[i]);
        }


        robot.computeCoriolisVector(); ///WARNING coriolis term introduces torque steps
        gsl_vector_add (VECTOR_VIEW(tau_view),robot.v);//tau+=v(q,qd)


        robot.computeGravityVector();
        gsl_vector_add (VECTOR_VIEW(tau_view),robot.g);//tau+=g(q)
        // print_gsl_vector(robot.g,"Mine_G");

        // 		robot.computeCoriolisVector();

        // 				print_gsl_vector(VECTOR_VIEW(qd_view),"Mine_qd");

        // print_gsl_vector(robot.v,"Mine_C");

        // 		gsl_vector_add (VECTOR_VIEW(tau_view),robot.v);//tau+=v(q)



        if (currentAction==teach)
            save_data();

        if (currentAction==play)
        {
            // 	Forward Kinematic Computation
            robot.forwardKin();
            // 	Jacobians Computation
            robot.computeJacobians();
            // 	Mass Matrix computation
            robot.computeMassMatrix();

            reproduce_data();
        }


        //    stores the q value into qd vector
        memcpy(qd,q,DOF*sizeof(Real));

    }
    pthread_mutex_unlock(&internal_variables_mutex);




}

    void
TeachPlay::save_data() //protected by mutex
{
    if (currentcyclenumber>=ncycles2recordSamples)
    {
        currentcyclenumber=0;
        for (int i=0;i<DOF;i++)
            teachFile<<q[i]<<" ";
        teachFile<<"\n";
    }

    currentcyclenumber++;

    // 	if (ref2control_idx!=0)
    // 	{
    // // 			save the joint positions and the torques
    // 		for (int i=0;i<DOF;i++)
    // 			playResultsFile<<q[i]<<" ";
    // 		for (int i=0;i<DOF;i++)
    // 			playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";
    // 		playResultsFile<<"\n";
    // 	}
}


// void
// TeachPlay::reproduce_data()
// {
//
// 	static Real error_pos[DOF];
// 	static bool achieved;
// 	for(int i=0;i<DOF;i++)
// 		error_pos[i]=fabs(refTab[ref2control_idx][i]-q[i]);
// 	if ((currentcyclenumber>=ncycles2reproduceSamples) && (ref2control_idx<(refTabSize-1)))
// 	{
// 		if(ref2control_idx==0)
// 		{
//
// 			achieved=true;
// 			for(int i=0;i<DOF;i++)
// 				if(error_pos[i]>(0.5/180.0*PI))
// 					achieved=false;
// 			if(achieved)
// 			{
// 				rt_make_soft_real_time();
// 				printf("\nACHIEVED");
// 				rt_make_hard_real_time();
//
// 				//change the controler in use ande initialize it
// 				controler_in_use=joint_controler_fast;
// 				initialize_controlers(controler_in_use);
//
// 				//increases the controlers reference
// 				ref2control_idx++;
//
// 				currentcyclenumber=-1;
// 			}
//
// 		}
// 		else
// 		{
// 			// 	save the joint positions and the torques
// 			for (int i=0;i<DOF;i++)
// 				playResultsFile<<q[i]<<" ";
// 			for (int i=0;i<DOF;i++)
// 				playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";
// 			playResultsFile<<"\n";
//
// 			currentcyclenumber=-1;
// 			//change the controlers reference
// 			ref2control_idx++;
// 		}
// 	}
//
// 	currentcyclenumber++;
//

// // 	//run the controlers
// 	gsl_vector_set_zero(tau_star);
// 	for(int i=0;i<DOF;i++)
// 	{
// // 		printf("\n\n\n\n\n\ncontroler:%d\n",i);
// // 		controler_in_use[i]->calc_output(1,2);
// 		GSL_VECTOR_SET(tau_star,i,controler_in_use[i]->calc_output(refTab[ref2control_idx][i],q[i]));
// 	}
// // 		currentAction=none;
// // 		printf("ref:%lf q:%lf",refTab[ref2control_idx][1],q[1]);
// // 	rt_make_soft_real_time();
// // 	print_gsl_vector(tau_star,"tau_star");
// // 	rt_make_hard_real_time();
//

// }

    void
TeachPlay::reproduce_data() //protected by mutex
{


    static Real error_pos[DOF];
    static bool achieved;
    if (ref2control_idx==0)
    {
        achieved=true;
        for(int i=0;i<DOF;i++)
        {
            if((error_pos[i]=fabs(refTab[ref2control_idx][i]-q[i]))>MIN_ERROR)
                achieved=false;

            if(qi[i]>refTab[ref2control_idx][i])
            {
                if(controler_ref[i]>refTab[ref2control_idx][i])
                    controler_ref[i]=-GOHOME_VELOCITY*h*currentcyclenumber+qi[i];
                else
                    controler_ref[i]=refTab[ref2control_idx][i];
            }
            else
            {
                if(controler_ref[i]<refTab[ref2control_idx][i])
                    controler_ref[i]=GOHOME_VELOCITY*h*currentcyclenumber+qi[i];
                else
                    controler_ref[i]=refTab[ref2control_idx][i];
            }
        }
        if(achieved)
        {
            printf("\nACHIEVED\n");

            currentcyclenumber=0;
            //change the controlers reference
            ref2control_idx++;
            for(int i=0;i<DOF;i++)
                controler_ref[i]=refTab[ref2control_idx][i];
        }
    }
    else
    {
        if ((currentcyclenumber>=ncycles2reproduceSamples) && (ref2control_idx<(refTabSize-1)))
        {
            currentcyclenumber=0;
            // 			change the controlers reference
            ref2control_idx++;
            for(int i=0;i<DOF;i++)
                controler_ref[i]=refTab[ref2control_idx][i];
        }
    }


    currentcyclenumber++;




    for(int i=0;i<DOF;i++)
    {
        ref_filtered[i]=alpha_ref*controler_ref[i]+(1-alpha_ref)*ref_filtered[i];
        GSL_VECTOR_SET(tau_star,i,controler_in_use[i]->calc_output(ref_filtered[i],q[i]));
    }

    // print_gsl_matrix( robot.M, "M_MINE");
    gsl_blas_dgemv (CblasNoTrans,1,robot.M,tau_star,1,VECTOR_VIEW(tau_view));


    if (ref2control_idx!=0)
    {
        // 			save the control filtered reference
        for (int i=0;i<DOF;i++)
            playResultsFile<<ref_filtered[i]<<" ";
        // 			save the joint positions and the torques
        for (int i=0;i<DOF;i++)
            playResultsFile<<q[i]<<" ";
        for (int i=0;i<DOF;i++)
            playResultsFile<<GSL_VECTOR_GET(VECTOR_VIEW(tau_view),i)<<" ";

        // 		for (int i=0;i<DOF;i++)
        // 			playResultsFile<<GSL_VECTOR_GET(tau_star,i)<<" ";

        playResultsFile<<"\n";
    }

}





    bool
TeachPlay::loadControlFiles()
{
    if(currentAction==play)
        return false;

    bool success=true;
    pthread_mutex_lock(&internal_variables_mutex);
    for (int i=0;i<DOF;i++)
    {
        success=joint_controler_fast[i]->reloadConfigFiles();
        if(!success)
            break;
        // 		success=joint_controler_slow[i]->reloadConfigFiles();
        // 		if(!success)
        // 			break;
    }
    pthread_mutex_unlock(&internal_variables_mutex);
    controlers_correctly_loaded=success;
    return success;
}




    void
TeachPlay::toggleAppState()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active && currentAction==none)
        active=false;
    else{
        for(int i=0;i<DOF;i++)
        {
            qd[i]=q[i];
        }
        active=true;
    }
    pthread_mutex_unlock(&internal_variables_mutex);
}

    bool
TeachPlay::isAppActive()
{
    return active;
}

    TeachPlay::action
TeachPlay::getAction()
{
    return currentAction;
}


    TeachPlay::results
TeachPlay::enableTeach()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(prepare4teach()) //TODO review if its correct
                {
                    pthread_mutex_lock(&internal_variables_mutex);
                    currentAction=teach;
                    pthread_mutex_unlock(&internal_variables_mutex);
                    return success;
                }
                else
                    return error;
                break;

            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(disablePlay()== success)
                {
                    if(prepare4teach()) //TODO review if its correct
                    {
                        pthread_mutex_lock(&internal_variables_mutex);
                        currentAction=teach;
                        pthread_mutex_unlock(&internal_variables_mutex);
                        return success;
                    }
                    else
                        return error;
                }
                else
                    return error;
                break;
            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}



    TeachPlay::results
TeachPlay::enablePlay()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(prepare4play()) //TODO review if its correct
                {
                    pthread_mutex_lock(&internal_variables_mutex);
                    currentAction=play;
                    pthread_mutex_unlock(&internal_variables_mutex);
                    return success;
                }
                else
                    return error;
                break;

            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                if(disableTeach()== success)
                {
                    if(prepare4play()) //TODO review if its correct
                    {
                        pthread_mutex_lock(&internal_variables_mutex);
                        currentAction=play;
                        pthread_mutex_unlock(&internal_variables_mutex);
                        return success;
                    }
                    else
                        return error;
                }
                else
                    return error;
                break;
            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}


    TeachPlay::results
TeachPlay::disableTeach()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;

            case play:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case teach:

                finishteach(); //TODO review if its correct
                currentAction=none;
                pthread_mutex_unlock(&internal_variables_mutex);
                return success;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}


    TeachPlay::results
TeachPlay::disablePlay()
{
    pthread_mutex_lock(&internal_variables_mutex);
    if(active)
        switch(currentAction)
        {
            case none:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case teach:
                pthread_mutex_unlock(&internal_variables_mutex);

                return nothingdone;
                break;
            case play:
                finishplay(); //TODO review if its correct
                currentAction=none;
                pthread_mutex_unlock(&internal_variables_mutex);
                return success;
                break;
            default:
                pthread_mutex_unlock(&internal_variables_mutex);

                return error;
        }
    else
    {
        pthread_mutex_unlock(&internal_variables_mutex);
        return nothingdone;
    }
}



    bool
TeachPlay::prepare4teach()
    // this function opens the file to record the joint positions from the WAM
{

    pthread_mutex_lock(&internal_variables_mutex);

    teachFile.open(teachFname.c_str(),ios::out);

    if(!teachFile.is_open()) return false;

    teachFile.setf(std::ios::fixed);
    teachFile.precision(4);

    teachFile<<"  %q1      q2      q3     q4     q5     q6      q7\n";

    pthread_mutex_unlock(&internal_variables_mutex);

    ncycles2recordSamples=(int)(DATACQUISITIONTIME/h+0.5);
    currentcyclenumber=0;
    cout<<"\nncycles2recordSamples:"<<ncycles2recordSamples<<"\n";


    // 	playResultsFile.open(PlayResultsFname.c_str(),ios::out);
    //
    // 	if(!playResultsFile.is_open()) return false;
    //
    // 	playResultsFile.setf(std::ios::fixed);
    // 	playResultsFile.precision(4);
    //
    // 	playResultsFile<<"     %q1     q2    q3     q4    q5      q6     q7     tau1    tau2    tau3     tau4   tau5   tau6   tau7\n";
    return true;
}


    bool
TeachPlay::finishteach() //protected by mutex
    // this function closes the file to record the joint positions from the WAM
{
    if(teachFile.is_open()) teachFile.close();
    if(playResultsFile.is_open()) playResultsFile.close();

    return true;
}




    bool
TeachPlay::prepare4play()
{
    if(!controlers_correctly_loaded)
    {
        std::cout<<"***************************************************\n";
        std::cout<<"controlers config files NOT correctly READED!!!\n"<< " please reload them!! (ONLY Teach mode is avaliable)\n";
        std::cout<<"***************************************************\n";
        return false;
    }

    if(!readReferences4table())
        return false;



    pthread_mutex_lock(&internal_variables_mutex);

    ncycles2reproduceSamples=(int)(DATAREPRODUCTIONTIME/h+0.5);
    cout<<"\nncycles2playSamples:"<<ncycles2reproduceSamples<<"\n";

    currentcyclenumber=0;
    ref2control_idx=0;
    controler_in_use=joint_controler_fast;

    initialize_controlers(controler_in_use,q);

    for(int i=0;i<DOF;i++)
    {
        qi[i]=q[i];
        qd[i]=q[i];
        controler_ref[i]=q[i];
        ref_filtered[i]=q[i];
    }

    pthread_mutex_unlock(&internal_variables_mutex);

    // 	cout<<"\n";

    return true;
}



    bool
TeachPlay::finishplay()  //protected by mutex
{
    for(int i=0;i<refTabSize;i++)
        delete [] refTab[i];
    delete [] refTab;
    refTab=0;

    if(playResultsFile.is_open()) playResultsFile.close();

    return true;
}

    void
TeachPlay::initialize_controlers(AOBcold **controler,Real ref[DOF])
{
    gsl_vector_set_zero(x_state_ini);
    for (int i=0;i<DOF;i++)
    {
        // 	initialize internal states
        GSL_VECTOR_SET(x_state_ini,0,q[i]);
        // 		print_gsl_vector(x_state_ini,"x_state_ini");
        controler[i]->setX_State(x_state_ini);

        // 	set the first reference and internal variables
        controler[i]->set_REF(ref[i]);
        controler[i]->reset_internal_variables(q[i]);
    }
}


    bool
TeachPlay::readReferences4table()
{
    teachFile.open(teachFname.c_str(),ios::in);

    if(!teachFile.is_open()) {
        std::cout<<"***************************************************\n";
        std::cout<<"                 COULD NOT OPEN TEACH FILE         \n";
        std::cout<<"***************************************************\n";
        return false;
    }


    // 	reads the number of lines in file
    refTabSize=0;
    char aux[150];
    cout<<"\nlocation:"<<teachFile.tellg()<<"\n";
    while( /*teachFile.ignore(3000, '\n' )*/!teachFile.eof() )
    {
        teachFile.getline(aux,150,'\n');
        /*cout<<"\naux:"<<aux<<"\n";*/
        refTabSize+=1;
    }
    refTabSize-=2;//decrements the header and the last line because doesn't have information
    cout<<"\n"<<refTabSize<<" readed lines\n";


    teachFile.close();
    teachFile.open(teachFname.c_str(),ios::in);


    teachFile.seekg(0,ios::beg); //Set the position of the get pointer in the begining of file
    // 	cout<<"\nlocation:"<<teachFile.tellg()<<"\n";
    char header[150];
    teachFile.getline(header,150);//removes the header
    cout<<"\nheader:"<<header<<"\n";
    // 	cout<<"\nlocation:"<<teachFile.tellg()<<"\n";

    // 	teachFile.seekg(0,ios::beg); //Set the position of the get pointer in the begining of file
    // 	char header1[150];
    // 	teachFile.getline(header1,150);//removes the header
    // 	cout<<"\nheader1:"<<header1<<"\n";
    // 	cout<<"\nlocation:"<<teachFile.tellg()<<"\n";

    refTab=new Real* [refTabSize];
    for(int i=0;i<refTabSize;i++)
    {
        refTab[i]=new Real [DOF];
        for(int j=0;j<DOF;j++){
            teachFile>>refTab[i][j];
            // 			cout<<refTab[i][j]<<" ";
        }
        // 		cout<<"\n";
    }

    teachFile.close();


    playResultsFile.open(PlayResultsFname.c_str(),ios::out);

    if(!playResultsFile.is_open()) return false;

    playResultsFile.setf(std::ios::fixed);
    playResultsFile.precision(4);

    playResultsFile<<"     %ref_q1     ref_q2    ref_q3     ref_q4    ref_q5      ref_q6     ref_q7     q1     q2    q3     q4    q5      q6     q7     tau1    tau2    tau3     tau4   tau5   tau6   tau7\n";

    return true;
}
